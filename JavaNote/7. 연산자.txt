1. 항과 연산자 
    1) 연산자(operator)
        - 연산에 사용하는 기호 
    2) 항(operand)
        - 연산에 사용하는 값

2. 연산자 구분 
    1) 단항 연산자 (항이 한 개인 연산자)
    2) 이항 연산자 (항이 두 개인 연산자)            
    3) 삼항 연산자 (항이 세 개인 연산자)

3. 대입 연산자 (assignment operator)
    1) 왼쪽 변수 = 오른쪽 변수(또는 식) 
        - lValue = rValue
        - 대입 연산자 기준으로 왼쪽에 있는 변수를 lValue (left Value),
          오른쪽에 있는 변수를 rValue(right Value)라고 함 

    2) 이항 연산자 중 우선순위가 가장 낮은 연산자    

4. 부호 연산자 
    1) +, -    

5. 산술 연산자 
    1) 사칙 연산에 사용하는 연산자 
    2) 곱셈(*), 나눗셈(/), 나머지(%)     

6. 증가, 감소 연산자 
    1) 단항 연산자
    2) 항 앞이나 뒤에 사용 
    3) 1만큼 늘리거나 1만큼 줄임 
    4) ++
        - 항의 값에 1을 더함 
        - 예)
            val = ++num;        //먼저 num값이 1 증가한 후  val 변수에 대입
            val = num++;        //val 변수에 기존 num값 먼저 대입한후 num값 1 증가

       --     
        - 항의 값에서 1을 뺌 
        - 예)
            val = --num;    //먼저 num값이 1 감소한 후 val 변수에 대입
            val = num--;    //val 변수에 기존 num 값을 대입한 후 num 값 1 감소     

7. 관계 연산자 (비교 연산자)
    1) 이항 연산자 
    2) 참 또는 거짓으로 반환 
    3) 연산자 
        >
        < 
        >=
        <=
        ==  두 개 항의 값이 같으면 참, 아니면 거짓을 반환함 
        !=  두 개 항이 다르면 참, 같으면 거짓을 반환함 

        - == (등가비교)  두 값이 동일한지 여부
          = (대입연산자) 오른쪽 값을 왼쪽에 대입
        - ==, != 비교할 때 비교 대상은 값
            - 스택 메모리의 값을 비교함 

8. 논리 연산자 
    - 진리표 
        값1     값2       AND(&&)    OR(||)   XOR(^)          값      NOT(!)   
        false   false     false      false    false
        false   true      false      true     true           false    true
        true    false     false      true     true           true     false
        true    true      true       true     false  

    - 쇼트 서킷(short circuit)
        - 단락 회로 평가 

9. 복합 대입 연산자
    1) 대입 연산자는 다른 연산자와 결합해 축약된 형태로 사용될 수 있음 
    2) 일반 표현                 축약 표현     
       ---------------------------------------
        a = a + b                 a += b
        a = a - b                 a -= b
        a = a * b                 a *= b  
                                  a /= b

10. 조건 연산자 (삼항 연산자)
    1) 연산에 필요한 항의 개수가 세 개임 
    2) 연산자 
        조건식 ? 결과1 : 결과2
    3) 조건식이 참이면 결과1 선택되고,
               거짓이면 결과 2가 선택됨     

11. 비트 연산자 
    1) 비트 단위로 연산이 이루어지는 연산자 
    2) 비트 논리 연산자 
        - AND(&), OR(|), XOR(^), NOT(~)
        - 진리표 
            값1     값2    AND(&)  OR(|)  XOR(^)        값  NOT(~)
          ----------------------------------------     -----------
             0       0      0       0      0 
             0       1      0       1      1            0   1
             1       0      0       1      1            1   0
             1       1      1       1      0 

        - & 연산자
            - 예)  int num1 = 5;                        0000 0101       
                   int num2 = 10;                     & 0000 1010
                   int result = num1 & num2;           ------------
                                                        0000 0000     

        - | 연산자
            - 예) int result = num1 | num2;            |
                                                       -------------
                                                        0000 1111  
                                                        10진수로 15가 나옴

        - ^ 연산자 
            - 같은 값이면 0, 다른 값이면 1의 결과 값을 갖음 
            - 예) int result = num1 ^ num2;             ^
                                                        --------------
                                                        0000 1111

        - ~ 연산자 
            - 반전 연산자 
            - 예) int num = 10;                         0000 1010
                  int result = ~num;                    1111 0101                                                                                                      
    3) 비트 이동 연산자 
        - 시프트(shift) 연산자 
        - 비트의 위치를 좌우로 이동하는 연산 
        - 구분 
            - 산술 시프트 (<<, >>)
            - 논리 시프트 (>>>)

        - << 연산자 
            - 왼쪽으로 비트를 이동하는 연산자임 
                - 예) int num = 5;              00000101
                      num << 2                  00010100
                    - 두 비트만큼 왼쪽으로 이동함 
                        - 이때 앞 두 자리 비트 00 => 없어짐
                        - 이때 뒷부분 0으로 채워짐
            - 왼쪽으로 n비트 이동하면 기존 값에 2^n 만큼 곱함 

        - >> 연산자 
            - 오른쪽으로 비트를 이동하는 연산자 
                - 예) int num = 10;             00001010             
                      num >> 2                  00000010
            - 오른쪽으로 n비트 이동하면 기존 값을 2^n만큼 나눔 

        - >>> 연산자 
            - >> 연산과 동일하게 비트를 오른쪽으로 이동함 
            - 채워지는 비트 값이 부호 비트와 상관없이 무조건 0이 됨 





                            